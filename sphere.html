<!DOCTYPE html>
<html>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
<style>
  h1 {}
  h2 {}
  p {  
     display: block;
     margin-top: 0;
     margin-bottom:1em;
     margin-left: 2em;
     margin-right: 0;
  }
  .logo_img {
     margin-right: 36px;
     width="40" 
     height="40"
  }
  .logo_box {
  }  
</style>

<body>

  prompt: make a pure javascript simulation of a sphere made up of ASCII numbers, rotating. The closest numbers should be pure white, and the farthest ones should fade to gray, on a white background

  <script>

const canvas = document.createElement("div");
document.body.style.cssText = "margin: 0; overflow: hidden; background: white;";
canvas.style.cssText = "font-family: monospace; white-space: pre; font-size: 10px; line-height: 10px;";
document.body.appendChild(canvas);

const width = 80; // ASCII sphere width
const height = 40; // ASCII sphere height
const radius = 15;
const chars = "0123456789";
let thetaX = 0.05, thetaY = 0.05;

const zBuffer = Array(width * height).fill(-Infinity);
const output = Array(width * height).fill(" ");
const points = [];

// Generate sphere points using spherical coordinates
for (let phi = 0; phi < Math.PI * 2; phi += Math.PI / 20) {
    for (let theta = 0; theta < Math.PI; theta += Math.PI / 20) {
        const x = radius * Math.sin(theta) * Math.cos(phi);
        const y = radius * Math.sin(theta) * Math.sin(phi);
        const z = radius * Math.cos(theta);
        points.push({ x, y, z });
    }
}

// Render loop
function render() {
    zBuffer.fill(-Infinity);
    output.fill(" ");

    for (let point of points) {
        const { x, y, z } = point;

        // Rotate around X and Y axes
        const rotatedX = x * Math.cos(thetaY) - z * Math.sin(thetaY);
        const rotatedZ = x * Math.sin(thetaY) + z * Math.cos(thetaY);
        const rotatedY = y * Math.cos(thetaX) - rotatedZ * Math.sin(thetaX);
        const finalZ = y * Math.sin(thetaX) + rotatedZ * Math.cos(thetaX);

        // Projection to 2D
        const projX = Math.floor((rotatedX / (finalZ + radius)) * width + width / 2);
        const projY = Math.floor((rotatedY / (finalZ + radius)) * height + height / 2);

        if (projX >= 0 && projX < width && projY >= 0 && projY < height) {
            const index = projY * width + projX;
            if (finalZ > zBuffer[index]) {
                zBuffer[index] = finalZ;
                const brightness = Math.floor(((finalZ + radius) / (2 * radius)) * (chars.length - 1));
                output[index] = chars[brightness];
            }
        }
    }

    canvas.textContent = output.join("").match(new RegExp(`.{1,${width}}`, "g")).join("\n");
    requestAnimationFrame(render);
}

// Mouse movement to control rotation
document.addEventListener("mousemove", (e) => {
    thetaX = (e.clientY / window.innerHeight - 0.5) * 0.1;
    thetaY = (e.clientX / window.innerWidth - 0.5) * 0.1;
});

render();


  </script>
  </body>
</html
