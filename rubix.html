<!DOCTYPE html>
<html>
<head>
<title>3D Rubik's Cube Simulation</title>
<style>
  body { margin: 0; overflow: hidden; background-color: white; }
  canvas { display: block; }
</style>
</head>
<body>2
  <canvas id="rubiksCanvas"></canvas>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

    const numRows = parseInt(prompt("Enter the number of rows for the Rubik's Cube (e.g., 3 for a standard cube):") || '3');
    const cubeSize = 1;
    const spacing = 0.01;
    const colors = [
      0xff0000, // Red
      0x00ff00, // Green
      0x0000ff, // Blue
      0xffff00, // Yellow
      0xffa500, // Orange
      0xffffff  // White
    ];

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('rubiksCanvas'), antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);

    const controls = new OrbitControls(camera, renderer.domElement);
    camera.position.z = numRows * 2;
    controls.update();

    const cubes = [];
    const group = new THREE.Group();
    scene.add(group);

    function createCube(x, y, z) {
      const geometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
      const materials = [];
      const halfSize = cubeSize / 2;

      // Order: +X, -X, +Y, -Y, +Z, -Z
      const px = x > (numRows - 1) / 2 + spacing / 2;
      const nx = x < (numRows - 1) / 2 - spacing / 2;
      const py = y > (numRows - 1) / 2 + spacing / 2;
      const ny = y < (numRows - 1) / 2 - spacing / 2;
      const pz = z > (numRows - 1) / 2 + spacing / 2;
      const nz = z < (numRows - 1) / 2 - spacing / 2;

      materials.push(new THREE.MeshBasicMaterial({ color: px ? colors[0] : 0x333333 })); // +X (Red)
      materials.push(new THREE.MeshBasicMaterial({ color: nx ? colors[1] : 0x333333 })); // -X (Green)
      materials.push(new THREE.MeshBasicMaterial({ color: py ? colors[2] : 0x333333 })); // +Y (Blue)
      materials.push(new THREE.MeshBasicMaterial({ color: ny ? colors[3] : 0x333333 })); // -Y (Yellow)
      materials.push(new THREE.MeshBasicMaterial({ color: pz ? colors[4] : 0x333333 })); // +Z (Orange)
      materials.push(new THREE.MeshBasicMaterial({ color: nz ? colors[5] : 0x333333 })); // -Z (White)

      const faceMaterials = [];
      for (let i = 0; i < 6; i++) {
        faceMaterials.push(materials[i]);
      }
      const material = new THREE.MeshFaceMaterial(faceMaterials);
      const cube = new THREE.Mesh(geometry, material);
      cube.position.set(
        (x - (numRows - 1) / 2) * (cubeSize + spacing),
        (y - (numRows - 1) / 2) * (cubeSize + spacing),
        (z - (numRows - 1) / 2) * (cubeSize + spacing)
      );
      return cube;
    }

    for (let i = 0; i < numRows; i++) {
      for (let j = 0; j < numRows; j++) {
        for (let k = 0; k < numRows; k++) {
          const cube = createCube(i, j, k);
          cubes.push(cube);
          group.add(cube);
        }
      }
    }

    const rotationSpeed = 0.1;
    let animating = false;
    let currentRotationAxis = new THREE.Vector3(0, 1, 0); // Default to Y-axis
    let currentRotationLayer = Math.floor(numRows / 2); // Default to middle layer
    let targetRotationAngle = 0;

    function rotateLayer(axis, layerIndex, angle) {
      const layer = [];
      const layerOffset = (layerIndex - (numRows - 1) / 2) * (cubeSize + spacing);

      cubes.forEach(cube => {
        const position = cube.position;
        if (Math.abs(axis.x) === 1 && Math.abs(position.x - layerOffset) < cubeSize / 2 + spacing / 2) {
          layer.push(cube);
        } else if (Math.abs(axis.y) === 1 && Math.abs(position.y - layerOffset) < cubeSize / 2 + spacing / 2) {
          layer.push(cube);
        } else if (Math.abs(axis.z) === 1 && Math.abs(position.z - layerOffset) < cubeSize / 2 + spacing / 2) {
          layer.push(cube);
        }
      });

      const rotationGroup = new THREE.Group();
      layer.forEach(cube => {
        group.remove(cube);
        rotationGroup.add(cube);
      });
      group.add(rotationGroup);

      const rotationPoint = new THREE.Vector3(
        Math.abs(axis.x) === 1 ? layerOffset : 0,
        Math.abs(axis.y) === 1 ? layerOffset : 0,
        Math.abs(axis.z) === 1 ? layerOffset : 0
      );
      rotationGroup.position.copy(rotationPoint);

      rotationGroup.rotation.reorder('XYZ');
      const startRotation = rotationGroup.rotation.clone();
      const endRotation = rotationGroup.rotation.clone();

      if (axis.x === 1) endRotation.x += angle;
      else if (axis.y === 1) endRotation.y += angle;
      else if (axis.z === 1) endRotation.z += angle;

      const animationDuration = 200; // milliseconds
      let startTime = null;

      function animateRotation(currentTime) {
        if (!startTime) startTime = currentTime;
        const elapsedTime = currentTime - startTime;
        const t = Math.min(1, elapsedTime / animationDuration);

        rotationGroup.rotation.slerp(endRotation, t);

        if (t < 1) {
          requestAnimationFrame(animateRotation);
        } else {
          // Re-attach cubes to the main group and update their world positions
          rotationGroup.updateWorldMatrix(true, true);
          layer.forEach(cube => {
            rotationGroup.remove(cube);
            scene.attach(cube); // Attach to scene to maintain world position
          });
          scene.remove(rotationGroup);
          animating = false;
        }
      }

      requestAnimationFrame(animateRotation);
    }

    document.addEventListener('keydown', (event) => {
      if (animating) return;

      const layerIndex = Math.floor(numRows / 2); // For simplicity, rotate middle layer

      switch (event.key.toLowerCase()) {
        case 'x':
          currentRotationAxis.set(1, 0, 0);
          rotateLayer(currentRotationAxis, layerIndex, Math.PI / 2);
          animating = true;
          break;
        case 'y':
          currentRotationAxis.set(0, 1, 0);
          rotateLayer(currentRotationAxis, layerIndex, Math.PI / 2);
          animating = true;
          break;
        case 'z':
          currentRotationAxis.set(0, 0, 1);
          rotateLayer(currentRotationAxis, layerIndex, Math.PI / 2);
          animating = true;
          break;
        case 'shift+x':
        case 'x+shift':
          currentRotationAxis.set(1, 0, 0);
          rotateLayer(currentRotationAxis, layerIndex, -Math.PI / 2);
          animating = true;
          break;
        case 'shift+y':
        case 'y+shift':
          currentRotationAxis.set(0, 1, 0);
          rotateLayer(currentRotationAxis, layerIndex, -Math.PI / 2);
          animating = true;
          break;
        case 'shift+z':
        case 'z+shift':
          currentRotationAxis.set(0, 0, 1);
          rotateLayer(currentRotationAxis, layerIndex, -Math.PI / 2);
          animating = true;
          break;
      }
    });

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
  </script>
</body>
</html>
